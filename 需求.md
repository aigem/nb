完整的实现计划：

  nbDraw Pipe 编排功能实现计划

  一、需求分析总结

  需求1：分辨率选择限制

  - gemini-2.5-flash-image-preview 和 gemini-2.5-flash-image
  不支持 1K/2K/4K 参数
  - 只有 gemini-3-pro-image-preview 支持分辨率选择
  - 需要根据选择的模型动态禁用/启用分辨率选项

  需求2：小游戏自动关闭

  - 当生成完成（isLoading 变为 false）时，小游戏应该自动关闭
  - 当前实现：小游戏在生成开始时自动打开，但完成后不会自动关闭
  - 需要添加延迟自动关闭逻辑（2-3秒），让用户看到"回复已就绪"状态

  需求3：删除批量功能

  - 删除"多图单词"（multi-image）模式
  - 删除"图片对多词"（image-multi-prompt）模式
  - 保留"普通批量"（normal）模式
  - 这些功能将被新的 Pipe 编排功能替代

  需求4：Pipe 编排功能（核心新功能）

  4.1 串行模式（Pipeline）

  初始图片 → [提示词1] → 图片A → [提示词2] → 图片B → [提示词3] →
  最终图片
  - 用户上传初始参考图
  - 定义多个步骤，每个步骤有独立的提示词
  - 每一步使用上一步的输出作为输入
  - 适用场景：渐进式优化、风格迁移、细节增强

  4.2 并行模式（Parallel）

  参考图 → [提示词1] → 结果1
         → [提示词2] → 结果2
         → [提示词3] → 结果3
  - 用户上传一张或多张参考图
  - 定义多个提示词
  - 所有提示词同时使用相同的参考图并行生成
  - 适用场景：风格探索、多方案对比

  4.3 用户界面需求

  - 独立的编排页面/面板
  - 可视化编排界面（添加步骤、配置提示词）
  - 支持保存和加载编排模板
  - 快捷按钮（使用预设模板）

  ---
  二、架构设计

  2.1 数据结构设计

  PipelineStep（编排步骤）

  interface PipelineStep {
    id: string;                    // 唯一标识
    prompt: string;                // 提示词
    order: number;                 // 执行顺序（串行模式）
    useReferenceImage: boolean;    // 是否使用参考图（并行模式）
    status: 'pending' | 'running' | 'completed' | 'error';
    resultImageId?: string;        // 生成结果的图片ID
    error?: string;                // 错误信息
  }

  Pipeline（编排配置）

  interface Pipeline {
    id: string;                    // 唯一标识
    name: string;                  // 编排名称
    description?: string;          // 描述
    mode: 'serial' | 'parallel';   // 串行/并行
    steps: PipelineStep[];         // 步骤列表
    initialImages: string[];       // 初始参考图（base64）
    createdAt: number;             // 创建时间
    updatedAt: number;             // 更新时间
  }

  PipelineTemplate（预设模板）

  interface PipelineTemplate {
    id: string;
    name: string;
    description: string;
    icon: string;                  // Lucide 图标名称
    mode: 'serial' | 'parallel';
    steps: Omit<PipelineStep, 'id' | 'status' |
  'resultImageId'>[];
    category: 'style' | 'enhance' | 'transform' | 'custom';
  }

  2.2 状态管理方案

  扩展 useUiStore

  interface UiState {
    // ... 现有状态

    // Pipe 编排相关
    isPipelineEditorOpen: boolean;
    currentPipeline: Pipeline | null;
    pipelineExecutionProgress: {
      currentStep: number;
      totalSteps: number;
      mode: 'serial' | 'parallel';
    } | null;

    // 操作方法
    openPipelineEditor: (template?: PipelineTemplate) => void;
    closePipelineEditor: () => void;
    setCurrentPipeline: (pipeline: Pipeline | null) => void;
    updatePipelineStep: (stepId: string, updates: 
  Partial<PipelineStep>) => void;
    setPipelineProgress: (progress: PipelineExecutionProgress | 
  null) => void;
  }

  扩展 useAppStore（持久化）

  interface AppState {
    // ... 现有状态

    // 保存的编排模板
    savedPipelines: Pipeline[];

    // 操作方法
    savePipeline: (pipeline: Pipeline) => void;
    deletePipeline: (id: string) => void;
    loadPipeline: (id: string) => Pipeline | null;
  }

  2.3 执行引擎设计

  PipelineExecutor（核心执行器）

  class PipelineExecutor {
    private pipeline: Pipeline;
    private abortController: AbortController;

    constructor(pipeline: Pipeline) {
      this.pipeline = pipeline;
      this.abortController = new AbortController();
    }

    // 执行串行编排
    async executeSerial(
      onStepStart: (step: PipelineStep) => void,
      onStepComplete: (step: PipelineStep, imageId: string) =>
  void,
      onStepError: (step: PipelineStep, error: string) => void
    ): Promise<void> {
      let currentImages = this.pipeline.initialImages;

      for (let i = 0; i < this.pipeline.steps.length; i++) {
        const step = this.pipeline.steps[i];
        onStepStart(step);

        try {
          // 调用 executeSingleGeneration
          const result = await this.generateImage(step.prompt,
  currentImages);
          onStepComplete(step, result.imageId);

          // 将结果作为下一步的输入
          currentImages = [result.base64Data];

          // 延迟避免限流
          if (i < this.pipeline.steps.length - 1) {
            await this.delay(500);
          }
        } catch (error) {
          onStepError(step, error.message);
          throw error; // 串行模式下，一步失败则终止
        }
      }
    }

    // 执行并行编排
    async executeParallel(
      onStepStart: (step: PipelineStep) => void,
      onStepComplete: (step: PipelineStep, imageId: string) =>
  void,
      onStepError: (step: PipelineStep, error: string) => void
    ): Promise<void> {
      const promises = this.pipeline.steps.map(async (step) => {
        onStepStart(step);

        try {
          const result = await this.generateImage(
            step.prompt,
            this.pipeline.initialImages
          );
          onStepComplete(step, result.imageId);
        } catch (error) {
          onStepError(step, error.message);
          // 并行模式下，单个失败不影响其他
        }
      });

      await Promise.all(promises);
    }

    // 生成单张图片（复用现有逻辑）
    private async generateImage(prompt: string, images: string[])
   {
      // 调用 ChatInterface 中的 executeSingleGeneration 逻辑
      // 返回生成的图片数据
    }

    // 中止执行
    abort() {
      this.abortController.abort();
    }

    private delay(ms: number) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  ---
  三、UI/UX 设计

  3.1 编排页面布局

  主界面结构

  ┌─────────────────────────────────────────────────────────┐
  │ [← 返回]  Pipe 编排器                    [保存] [执行]  │
  ├─────────────────────────────────────────────────────────┤
  │                                                           │
  │  模式选择: ○ 串行模式  ● 并行模式                        │
  │                                                           │
  │  ┌─────────────────────────────────────────────────┐   │
  │  │ 初始参考图                                       │   │
  │  │  [+] 上传图片  [图片1] [图片2]                  │   │
  │  └─────────────────────────────────────────────────┘   │
  │                                                           │
  │  ┌─────────────────────────────────────────────────┐   │
  │  │ 步骤列表                              [+ 添加步骤] │   │
  │  │                                                   │   │
  │  │  ┌──────────────────────────────────────────┐  │   │
  │  │  │ 步骤 1                          [↑][↓][×] │  │   │
  │  │  │ 提示词: ________________________          │  │   │
  │  │  │ 状态: ⏳ 等待中                           │  │   │
  │  │  └──────────────────────────────────────────┘  │   │
  │  │                                                   │   │
  │  │  ┌──────────────────────────────────────────┐  │   │
  │  │  │ 步骤 2                          [↑][↓][×] │  │   │
  │  │  │ 提示词: ________________________          │  │   │
  │  │  │ 状态: ⏳ 等待中                           │  │   │
  │  │  └──────────────────────────────────────────┘  │   │
  │  │                                                   │   │
  │  └─────────────────────────────────────────────────┘   │
  │                                                           │
  │  预设模板:                                               │
  │  [风格迁移] [渐进优化] [细节增强] [多风格探索]          │
  │                                                           │
  └─────────────────────────────────────────────────────────┘

  执行进度界面

  ┌─────────────────────────────────────────────────────────┐
  │ 正在执行编排: 风格迁移                        [停止]    │
  ├─────────────────────────────────────────────────────────┤
  │                                                           │
  │  进度: 步骤 2 / 4                                        │
  │  ████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░ 50%          │
  │                                                           │
  │  ✓ 步骤 1: 转换为线稿 (完成)                            │
  │  ⏳ 步骤 2: 添加水彩效果 (进行中...)                     │
  │  ⏸ 步骤 3: 增强细节 (等待中)                            │
  │  ⏸ 步骤 4: 调整色调 (等待中)                            │
  │                                                           │
  └─────────────────────────────────────────────────────────┘

  3.2 快捷按钮设计

  在 InputArea 的批量模式选择器旁边添加：

  <button
    onClick={() => openPipelineEditor()}
    className="px-3 py-1.5 rounded-lg text-xs font-medium 
  bg-purple-100 dark:bg-purple-900/30 text-purple-600 
  dark:text-purple-400 hover:bg-purple-200 
  dark:hover:bg-purple-800/40"
  >
    <Workflow className="h-3 w-3 inline mr-1" />
    编排
  </button>

  <button
    onClick={() => openPipelineEditor(PARALLEL_STYLE_TEMPLATE)}
    className="px-3 py-1.5 rounded-lg text-xs font-medium
  bg-blue-100 dark:bg-blue-900/30 text-blue-600
  dark:text-blue-400"
  >
    <Sparkles className="h-3 w-3 inline mr-1" />
    多风格
  </button>

  3.3 预设模板设计

  模板1: 风格迁移（串行）

  {
    name: "风格迁移",
    description: "将图片逐步转换为特定艺术风格",
    mode: "serial",
    steps: [
      { prompt: "Convert to line art sketch", order: 1 },
      { prompt: "Add watercolor painting style", order: 2 },
      { prompt: "Enhance details and textures", order: 3 },
      { prompt: "Adjust color tone to warm palette", order: 4 }
    ]
  }

  模板2: 渐进优化（串行）

  {
    name: "渐进优化",
    description: "逐步提升图片质量和细节",
    mode: "serial",
    steps: [
      { prompt: "Enhance image resolution and clarity", order: 1
  },
      { prompt: "Improve lighting and shadows", order: 2 },
      { prompt: "Add fine details and textures", order: 3 }
    ]
  }

  模板3: 多风格探索（并行）

  {
    name: "多风格探索",
    description: "同时生成多种艺术风格版本",
    mode: "parallel",
    steps: [
      { prompt: "Convert to anime style", order: 1 },
      { prompt: "Convert to oil painting style", order: 2 },
      { prompt: "Convert to cyberpunk style", order: 3 },
      { prompt: "Convert to minimalist style", order: 4 }
    ]
  }

  模板4: 细节增强（并行）

  {
    name: "细节增强",
    description: "从不同角度增强图片细节",
    mode: "parallel",
    steps: [
      { prompt: "Enhance facial features and expressions", order:
   1 },
      { prompt: "Improve background details", order: 2 },
      { prompt: "Add realistic lighting effects", order: 3 }
    ]
  }

  ---
  四、技术实现方案

  4.1 需要新增的组件

  1. PipelineEditor.tsx（编排编辑器）

  - 主编排界面
  - 步骤管理（添加、删除、排序）
  - 模式切换（串行/并行）
  - 保存/加载功能

  2. PipelineStepCard.tsx（步骤卡片）

  - 单个步骤的编辑界面
  - 提示词输入
  - 状态显示
  - 操作按钮（上移、下移、删除）

  3. PipelineExecutionPanel.tsx（执行进度面板）

  - 实时进度显示
  - 步骤状态可视化
  - 停止按钮
  - 结果预览

  4. PipelineTemplateSelector.tsx（模板选择器）

  - 预设模板展示
  - 模板预览
  - 快速应用

  5. PipelineResultViewer.tsx（结果查看器）

  - 展示所有生成的图片
  - 对比视图（串行模式显示演变过程）
  - 下载/保存功能

  4.2 需要修改的现有组件

  1. InputArea.tsx

  - 删除"多图单词"和"图片对多词"按钮
  - 添加"编排"和"多风格"快捷按钮
  - 简化批量模式选择器

  修改位置：第192-255行

  2. ChatInterface.tsx

  - 删除 multi-image 和 image-multi-prompt 的处理逻辑
  - 添加 Pipeline 执行入口
  - 集成 PipelineExecutor

  修改位置：第77-119行（批量任务构建）

  3. SettingsPanel.tsx

  - 根据选择的模型禁用/启用分辨率选项
  - 添加提示文本说明

  修改位置：第148-171行（分辨率选择）

  4. ThinkingIndicator / ChatInterface

  - 添加自动关闭逻辑

  修改位置：ChatInterface.tsx 第44行后

  4.3 与现有批量功能的集成

  复用现有逻辑

  // 在 ChatInterface.tsx 中添加
  const executePipeline = async (pipeline: Pipeline) => {
    const executor = new PipelineExecutor(pipeline);

    try {
      if (pipeline.mode === 'serial') {
        await executor.executeSerial(
          (step) => {
            // 更新步骤状态为 running
            updatePipelineStep(step.id, { status: 'running' });
          },
          (step, imageId) => {
            // 更新步骤状态为 completed
            updatePipelineStep(step.id, {
              status: 'completed',
              resultImageId: imageId
            });
          },
          (step, error) => {
            // 更新步骤状态为 error
            updatePipelineStep(step.id, {
              status: 'error',
              error
            });
          }
        );
      } else {
        await executor.executeParallel(/* 同上 */);
      }

      addToast('编排执行完成！', 'success');
    } catch (error) {
      addToast(`编排执行失败: ${error.message}`, 'error');
    } finally {
      setPipelineProgress(null);
    }
  };

  图片传递机制

  - 串行模式：每步的输出自动成为下一步的输入
  - 并行模式：所有步骤共享初始参考图
  - 使用 base64 格式在步骤间传递

  4.4 错误处理和中断机制

  错误处理策略

  - 串行模式: 任一步骤失败则终止整个编排
  - 并行模式: 单个步骤失败不影响其他步骤
  - 显示详细错误信息和失败的步骤

  中断机制

  // 用户点击停止按钮
  const handleStopPipeline = () => {
    if (pipelineExecutorRef.current) {
      pipelineExecutorRef.current.abort();
      addToast('编排已停止', 'info');
      setPipelineProgress(null);
    }
  };

  ---
  五、实现优先级

  MVP 功能（第一阶段）

  任务1: 修复现有问题（1-2小时）

  - 分辨率选择限制（根据模型禁用选项）
  - 小游戏自动关闭（添加延迟关闭逻辑）
  - 删除多图单词和图片对多词功能

  任务2: 基础 Pipe 功能（4-6小时）

  - 数据结构定义（types.ts）
  - 状态管理扩展（useUiStore, useAppStore）
  - PipelineExecutor 核心执行器
  - 基础编排编辑器（PipelineEditor.tsx）
  - 步骤卡片组件（PipelineStepCard.tsx）

  任务3: 串行模式实现（2-3小时）

  - 串行执行逻辑
  - 图片传递机制
  - 进度显示
  - 结果展示

  任务4: 并行模式实现（2-3小时）

  - 并行执行逻辑（Promise.all）
  - 进度显示
  - 结果展示

  增强功能（第二阶段）

  任务5: 预设模板（2-3小时）

  - 4个预设模板实现
  - 模板选择器界面
  - 快捷按钮集成

  任务6: 保存/加载功能（2-3小时）

  - 编排持久化存储
  - 加载已保存的编排
  - 编排管理界面

  任务7: 结果优化（2-3小时）

  - 结果对比视图
  - 批量下载
  - 添加到历史记录

  未来扩展（第三阶段）

  任务8: 高级功能

  - 条件分支（if-else 逻辑）
  - 循环执行（repeat N times）
  - 参数化提示词（变量替换）
  - 可视化流程图编辑器

  任务9: 社区功能

  - 分享编排模板
  - 导入/导出 JSON
  - 模板市场

  ---
  六、文件清单

  新增文件

  src/
  ├── components/
  │   ├── pipeline/
  │   │   ├── PipelineEditor.tsx          # 编排编辑器主界面
  │   │   ├── PipelineStepCard.tsx        # 步骤卡片
  │   │   ├── PipelineExecutionPanel.tsx  # 执行进度面板
  │   │   ├── PipelineTemplateSelector.tsx # 模板选择器
  │   │   └── PipelineResultViewer.tsx    # 结果查看器
  │   └── ...
  ├── services/
  │   └── pipelineExecutor.ts             # 执行引擎
  ├── utils/
  │   └── pipelineUtils.ts                # 工具函数
  └── types.ts                             # 类型定义扩展

  修改文件

  src/
  ├── components/
  │   ├── InputArea.tsx                    #
  删除批量按钮，添加编排按钮
  │   ├── ChatInterface.tsx                #
  删除批量逻辑，添加编排执行
  │   ├── SettingsPanel.tsx                # 分辨率选择限制
  │   └── ThinkingIndicator.tsx            # 自动关闭逻辑
  ├── store/
  │   ├── useUiStore.ts                    # 添加编排状态
  │   └── useAppStore.ts                   # 添加编排持久化
  └── types.ts                             # 添加 Pipeline
  相关类型

  ---
  七、实现细节补充

  7.1 分辨率选择限制实现

  // SettingsPanel.tsx
  const isResolutionSupported = (modelName: string) => {
    return modelName === 'gemini-3-pro-image-preview';
  };

  // 在分辨率选择部分
  {(['1K', '2K', '4K'] as const).map((res) => {
    const isSupported = isResolutionSupported(settings.modelName
  || '');
    return (
      <button
        key={res}
        onClick={() => {
          if (!isSupported) return;
          // ... 现有逻辑
        }}
        disabled={!isSupported}
        className={`... ${!isSupported ? 'opacity-50
  cursor-not-allowed' : ''}`}
      >
        {res}
      </button>
    );
  })}

  {!isResolutionSupported(settings.modelName || '') && (
    <p className="text-xs text-gray-400 mt-2">
      当前模型不支持分辨率选择，仅 Gemini 3 Pro 支持此功能。
    </p>
  )}

  7.2 小游戏自动关闭实现

  // ChatInterface.tsx
  useEffect(() => {
    if (!isLoading && showArcade) {
      // 延迟 2.5 秒自动关闭
      const timer = setTimeout(() => {
        handleCloseArcade();
      }, 2500);

      return () => clearTimeout(timer);
    }
  }, [isLoading, showArcade]);

  7.3 删除批量功能

  // InputArea.tsx - 删除这些按钮
  // 第206-215行: 多图单词按钮
  // 第216-225行: 图片对多词按钮

  // ChatInterface.tsx - 删除这些逻辑
  // 第85-94行: multi-image 处理
  // 第95-118行: image-multi-prompt 处理

  // useUiStore.ts - 修改类型
  export type BatchMode = 'off' | 'normal'; // 删除 'multi-image'
   | 'image-multi-prompt'

  ---
  八、测试计划

  单元测试

  - PipelineExecutor 串行执行
  - PipelineExecutor 并行执行
  - 步骤状态更新
  - 错误处理

  集成测试

  - 完整串行流程（3步）
  - 完整并行流程（4个提示词）
  - 中断执行
  - 保存/加载编排

  用户测试场景

  1. 上传一张照片，使用"风格迁移"模板，查看4步演变过程
  2. 上传一张照片，使用"多风格探索"模板，同时生成4种风格
  3. 自定义编排：3步串行优化
  4. 保存编排，下次直接加载使用
  5. 执行中途停止

  ---
  九、总结

  这个实现计划提供了一个完整的 Pipe 编排功能架构，包括：

  1. 清晰的数据结构: Pipeline, PipelineStep, PipelineTemplate
  2. 灵活的执行引擎: 支持串行和并行两种模式
  3. 直观的用户界面: 可视化编排、实时进度、结果展示
  4. 良好的扩展性: 预设模板、保存/加载、未来可扩展高级功能
  5. 与现有系统的无缝集成: 复用 executeSingleGeneration 逻辑

  MVP 功能预计 10-15 小时可完成，增强功能再需 6-9 小时，总计约
  2-3 个工作日可实现完整功能。